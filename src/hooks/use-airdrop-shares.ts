'use client';

import { DistributionContract, ShareData, OnChainShare } from '@/lib/core/contracts/distribution';
import { useCallback, useState } from 'react';
import { getAddress } from 'viem';
import { useClient, useConnection } from 'wagmi';

export type AirdropShareModel = {
  shareData: ShareData;
  isRevealed: boolean;
  onChainShare?: OnChainShare;
  claimable?: bigint;
  claimed?: bigint;
  availableToClaim?: bigint;
};

export type UseAirdropSharesResult =
  | {
      status: 'not_connected';
    }
  | {
      status: 'error';
      error: string;
    }
  | {
      status: 'loading';
    }
  | {
      status: 'loaded';
      shares: AirdropShareModel[];
      selectedShareId: string | null;
    };

export function useAirdropShares(): [
  UseAirdropSharesResult,
  () => Promise<void>,
  (shareId: string | null) => void
] {
  const [result, setResult] = useState<UseAirdropSharesResult>({ status: 'loading' });
  const [selectedShareId, setSelectedShareId] = useState<string | null>(null);
  const client = useClient();
  const { address } = useConnection();

  const selectShare = useCallback((shareId: string | null) => {
    setSelectedShareId(shareId);
    setResult((prev) => {
      if (prev.status === 'loaded') {
        return { ...prev, selectedShareId: shareId };
      }
      return prev;
    });
  }, []);

  const execute = useCallback(async () => {
    if (address == undefined) {
      setResult({ status: 'not_connected' });
      return;
    }

    if (client == undefined) {
      setResult({ status: 'loading' });
      return;
    }

    setResult({ status: 'loading' });

    try {
      // Fetch shares from GitHub
      const url = `https://raw.githubusercontent.com/worm-privacy/genesis/refs/heads/main/autogenerated/${address.toLowerCase()}.json`;
      const response = await fetch(url);
      
      if (!response.ok) {
        if (response.status === 404) {
          setResult({
            status: 'loaded',
            shares: [],
            selectedShareId: null,
          });
          return;
        }
        throw new Error(`Failed to fetch shares: ${response.status}`);
      }

      const sharesData: ShareData[] = await response.json();
      
      // Check each share's reveal status on-chain and fetch claimable amounts
      const shares: AirdropShareModel[] = await Promise.all(
        sharesData.map(async (shareData) => {
          try {
            const onChainShare = await DistributionContract.getShare(client, BigInt(shareData.id));
            const isRevealed = onChainShare.owner !== '0x0000000000000000000000000000000000000000';
            
            if (isRevealed) {
              const [claimable, claimed] = await Promise.all([
                DistributionContract.calculateClaimable(client, BigInt(shareData.id)),
                DistributionContract.getShareClaimed(client, BigInt(shareData.id)),
              ]);
              const availableToClaim = claimable - claimed;
              return {
                shareData,
                isRevealed,
                onChainShare,
                claimable,
                claimed,
                availableToClaim
              };
            }
            
            return {
              shareData,
              isRevealed: false,
            };
          } catch (e) {
            console.error(`Error checking share ${shareData.id}:`, e);
            return {
              shareData,
              isRevealed: false,
            };
          }
        })
      );

      const newSelectedShareId = shares.length > 0 ? shares[0].shareData.id : null;
      setSelectedShareId(newSelectedShareId);
      setResult({
        status: 'loaded',
        shares,
        selectedShareId: newSelectedShareId,
      });
    } catch (e) {
      console.error(e);
      setResult({ status: 'error', error: 'Error loading airdrop data' });
    }
  }, [client, address]);

  return [result, execute, selectShare];
}
